// pragma solidity ^0.4.24;
pragma experimental ABIEncoderV2;



I dont think I can use the array shortcut to storing node because, althought we dont need search, we do need the ability to delete a specified node. The user will know all the details about the node, however, in a heap using the array method, the node could have moved at any time due to swaps. We have no way to pinpoint the index, and if we do, it is insecure. because it can be changed by attackers deleting at any time (deleting causes swaps).

Its ok, we can still use a heap, but the nodes will be stored in a mapping using pointers. The nodes need up and down pointers I believe (unless its possible to write a top-down process for inserts).

ok, so its not that we need to track the size anymore. we need the pointer to the next open node. Shoot, Im not sure we even have that. maybe if we just keep track of what level. as long as we insert from the bottom we just need to pick a single node with the lowest level count

ok I got it here are the storage requirements:

mapping (uint => uint) indices // uid=>index

struct Node{
  price       // heap value
  amount      
  createdAt   
  user        
}

Node[] nodes

------
  11
 5  8
3 4 2 1
------

[3,8,11,5,4,2,1]

    GAS | heapify    push  pop (gas/tx)
=======================================
uint256 |  632304  146266   89781/59781
uint128 |  479039  113513  112639/67639
 uint32 |  474829

removed(id 4?)
get(id 5) ->throws error...

3

  8
 3

  11
 3  8

  11
 5  8
3
------
  11
 5  8
3 4
------
  8
 5 4
3

  5
 3 4
lines 51

Node mem c
ci = i*2+1
if(l > ci)
  c = nodes[ci] > nodes[ci-1] ? nodes[ci] : nodes[ci-1]
  if(n < c)
    insert(c) ; bubbleDown(ci)
elsif(l > ci-1)
  c = nodes[--ci]
else
if(c <= n)
  insert(n)
else
  insert(c)
  bubbleDown(c, ci)




with no nodes:
max -> error
getByPosition -> error (if pos is empty)




HeapClient at Kovan: 0x0b534811877e79f0d44f7861273aca0efb19873c 
(returning `Heap.Node`s)


ok so it would be nice to have a few things:
1: add another function 

var dumpSig = web3.eth.abi.encodeFunctionSignature("dump()")






// var encArgs = (func, args)=>{
//     function splice(str, index, count, add) {
//         if (index < 0) {
//             index = str.length + index;
//             if (index < 0) {
//                 index = 0;
//             }
//         }
//         return str.slice(0, index) + (add || "") + str.slice(index + count);
//     }

//     let type = 'uint128[]'
//     let types = []
//     let values = []

//     for (var i = 0; i < args.length; i++) {
//         types.push(type)
//         values.push(args[i])
//     }
//     return splice(web3.eth.abi.encodeParameter(type, values),0,2,web3.eth.abi.encodeFunctionSignature(func))
// }

  // before((done) => {
  //   user1 = accounts[0]
  //   // Truffle deploys contracts with accounts[0]
  //   Proxy.new({from: accounts[0]}).then((instance) => {
  //     registryV3 = instance
  //     done()
  //   })
  // })


// var web3 = require('web3');


// class Heap extends Array{
//   constructor(..._priorities){
//     let priorities = new Array(..._priorities)
//     super(0)
//     for (var i = 0; i < priorities.length; i++) {
//       this.push(priorities[i])
//     }
//   }

//   push(n){ this.pushSubTree(n, this.length) }

//   pushSubTree(n, i){
//     var parentIndex = Math.floor((i-1)/2) // or nil? doesn look right for i = 0
//     if(n > this[parentIndex]){
//       this[i] = this[parentIndex]
//       this.pushSubTree(n, parentIndex)
//     }else{
//       this[i] = n
//     }
//   }

//   pop(){
//     var max = this[0]
//     this[0] = super.pop()
//     this.bubbleDown(0)
//     return max
//   }
//   delete(i){
//     this[i] = super.pop()
//     this.bubbleUp(i)
//     this.bubbleDown(i)
//   }

//   bubbleUp(i){
//     var parentIndex = this.pIndex(i)
//     var parentPriority = this[parentIndex]
//     if(this[i] > parentPriority){
//       this[parentIndex] = this[i]
//       this[i] = parentPriority
//       this.bubbleUp(parentIndex)
//     }
//   }

//   bubbleDown(i){
//     var childIndex
//     var childPriority
//     if(this[i] <= this[this.lIndex(i)] || this[i] <= this[this.rIndex(i)]){
//       childIndex = this[this.lIndex(i)] > this[this.rIndex(i)] ? this.lIndex(i) : this.rIndex(i) //max child
//       childPriority = this[childIndex]
//       this[childIndex] = this[i]
//       this[i] = childPriority
//       this.bubbleDown(childIndex)
//     }
//   }

//   pIndex(i){ return Math.floor((i-1)/2) }
//   lIndex(i){ return i*2 + 1}
//   rIndex(i){ return i*2 + 2}

//   _print(){
//     var l = this.length
//     console.log(this)
//     for (var j = 0; 2**j < this.length; j++) {
//     for (var k = 0; k*3 < l-2**j; k++) { process.stdout.write(" ")} 
//       for (var i = 0; i < this.length; i++) {
//         if(i >= 2**j-1 && i < 2**(j+1)-1){
//           if(this[i]) process.stdout.write((this[i]).toString())
//         }else{
//           process.stdout.write("")
//         }
//       }
//       console.log("")
//     }
//   }

//   _print2(){
//     var obj = {}
//     obj[this[0]] = Heap._toObject(this, 0)
//     console.log(treeify.asTree(obj, false));
//     console.log(obj)
//   }

//   static _toObject(arr, i) {
//     var obj = {}
//     if(i*2+1 < arr.length) obj[arr[i*2+1]] = Heap._toObject(arr, i*2+1)
//     if(i*2+2 < arr.length) obj[arr[i*2+2]] = Heap._toObject(arr, i*2+2)
//     return obj
//   }
// }


DELEGATE.SOL
pragma solidity ^0.4.23;

import "./Heap.sol";

contract Delegate{ // an upgradeable interface

  using Heap for Heap.Data;
  Heap.Data public data;

  struct MarketOrder{
    //uint32 id;           // holds up to 2.4 billion 32
    //uint64 price;        // implied market cap of 200 Billion 38
    uint56 amount;       // entire supply 52
    uint40 createdAt;    // thousand years 36
    address user;        //+160 = 318 bits :(
  }
  mapping(uint128 => MarketOrder) marketOrders; 

  address implementation;        // key: 0
  address collective;            // key: 1

  constructor(address _implementation, address _collective){ 
    implementation = _implementation; 
    collective   = _collective;
  }

  function () public payable{
    assembly{
      let m := mload(0x40)
      calldatacopy(m,0,calldatasize)
      let success := delegatecall(gas, sload(implementation_slot), m, calldatasize, m, 0)
      returndatacopy(m,0,returndatasize)

      switch success
      case 0 { revert(m, returndatasize()) }
      default { return(m, returndatasize()) }
    }
  }

}


BOUNTY:
create a contract that releases funds iff you are able to prove the heap invariant has been violated. 1: that any parent you can point to is less than its child. Look up the other definitions of the heap. find ways to contractually prove breakage of an invariant.


SUPPORTS HEAP DEFINITION
  SUPPORTS BINARY TREE DEFINITION

  Shape property: a binary heap is a complete binary tree; that is, all levels of the tree, except possibly the last one (deepest) are fully filled, and, if the last level of the tree is not complete, the nodes of that level are filled from left to right.

  Heap property: the key stored in each node is either greater than or equal to (≥) or less than or equal to (≤) the keys in the node's children, according to some total order.




2600 1TB

3000 1TB *
3800 2TB


I just deployed a 10 ETH bounty contract to the wild. details in #priv-dev-roundtable



@channel: I just deployed a 10 ETH bug bounty for all of you to try and break :) Happy Friday!

It's a Heap data structure. I needed as infrastructure for an X-Relay feature, but it should be useful for a wide range of dapplications ;) so I did it as a library, and am building some js tools around it. Its going to secure a lot of value some day so lets start the pen-testing. details/contractAddress/etherscanCode can all be found on this github readme: https://github.com/zmitton/eth-heap#bounty

The plan is to give the Consensys fam this weekend as a head start before I publish the bounty to wider social media (and possibly raise the stakes). So try to keep it on the DL until Monday.


Unless someone breaks it immediately - which is entirely possible, This is the first review of-any-kind I'm getting besides my own




This could end in  disaster for me, but I did this over a year ago with 10 ETH in the uPort contracts. As of now I remain unSpanked


-------------------
 reddit(ethereum, ethereum-classic?, ethereum-devs), blog
Channels: slack(consensys), telegram(p.r. devs), messenger(roadsters)
(facebook, gitcoin, hackernews, 4chan)?

TWEET
I created a Heap data structure on Ethereum to mitigate gas-limit attacks, and just deployed a 15 ETH live bounty for anyone who can break it. I'll keep adding more ETH until at least Oct 31. details on my github: https://github.com/zmitton/eth-heap#bounty

I put a Live, 15 ETH Open Bounty Contract for Anyone to Break My Heap Implementation 

REDDIT (ethereum, ethereum-classic?, ethereum-devs)
"I just deployed a 10 ETH bug bounty for all of you to try and break :boom: Happy Friday!

It’s a Heap data structure. I needed it as infrastructure for an X-Relay feature, but it should be useful for a wide range of dapplications :troll: so I did it as a library, and am building some js tools around it. It will have to secure a lot of value eventually so lets start the pen-testing. details/contractAddress/etherscanCode can all be found on this github readme:"





